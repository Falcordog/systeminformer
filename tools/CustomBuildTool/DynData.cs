/*
 * Copyright (c) 2022 Winsider Seminars & Solutions, Inc.  All rights reserved.
 *
 * This file is part of System Informer.
 *
 * Authors:
 *
 *     jxy-s
 *
 */

namespace CustomBuildTool
{
    using ULONG = UInt32;
    using USHORT = UInt16;

    public static class DynData
    {
        private const string FileHeader =
@"/*
 * Copyright (c) 2022 Winsider Seminars & Solutions, Inc.  All rights reserved.
 *
 * This file is part of System Informer.
 *
 * THIS IS AN AUTOGENERATED FILE, DO NOT MODIFY
 *
 */";

        private const string Includes =
@"#include <kphlibbase.h>";

        private const ULONG Version = 10;

        private static string DynConfigC =
$@"#define KPH_DYN_CONFIGURATION_VERSION { Version }

#define KPH_DYN_CI_INVALID ((SHORT)-1)
#define KPH_DYN_CI_V1      ((SHORT)1)
#define KPH_DYN_CI_V2      ((SHORT)2)

#define KPH_DYN_LX_INVALID ((SHORT)-1)
#define KPH_DYN_LX_V1      ((SHORT)1)

#include <pshpack1.h>

typedef struct _KPH_DYN_CONFIGURATION
{{
    USHORT MajorVersion;
    USHORT MinorVersion;
    USHORT BuildNumberMin;               // -1 to ignore
    USHORT RevisionMin;                  // -1 to ignore
    USHORT BuildNumberMax;               // -1 to ignore
    USHORT RevisionMax;                  // -1 to ignore

    USHORT EgeGuid;                      // dt nt!_ETW_GUID_ENTRY Guid
    USHORT EpObjectTable;                // dt nt!_EPROCESS ObjectTable
    USHORT EreGuidEntry;                 // dt nt!_ETW_REG_ENTRY GuidEntry
    USHORT HtHandleContentionEvent;      // dt nt!_HANDLE_TABLE HandleContentionEvent
    USHORT OtName;                       // dt nt!_OBJECT_TYPE Name
    USHORT OtIndex;                      // dt nt!_OBJECT_TYPE Index
    USHORT ObDecodeShift;                // dt nt!_HANDLE_TABLE_ENTRY ObjectPointerBits
    USHORT ObAttributesShift;            // dt nt!_HANDLE_TABLE_ENTRY Attributes
    USHORT CiVersion;                    // ci.dll exports version
    USHORT AlpcCommunicationInfo;        // dt nt!_ALPC_PORT CommunicationInfo
    USHORT AlpcOwnerProcess;             // dt nt!_ALPC_PORT OwnerProcess
    USHORT AlpcConnectionPort;           // dt nt!_ALPC_COMMUNICATION_INFO ConnectionPort
    USHORT AlpcServerCommunicationPort;  // dt nt!_ALPC_COMMUNICATION_INFO ServerCommunicationPort
    USHORT AlpcClientCommunicationPort;  // dt nt!_ALPC_COMMUNICATION_INFO ClientCommunicationPort
    USHORT AlpcHandleTable;              // dt nt!_ALPC_COMMUNICATION_INFO HandleTable
    USHORT AlpcHandleTableLock;          // dt nt!_ALPC_HANDLE_TABLE Lock
    USHORT AlpcAttributes;               // dt nt!_ALPC_PORT PortAttributes
    USHORT AlpcAttributesFlags;          // dt nt!_ALPC_PORT_ATTRIBUTES Flags
    USHORT AlpcPortContext;              // dt nt!_ALPC_PORT PortContext
    USHORT AlpcPortObjectLock;           // dt nt!_ALPC_PORT PortObjectLock
    USHORT AlpcSequenceNo;               // dt nt!_ALPC_PORT SequenceNo
    USHORT AlpcState;                    // dt nt!_ALPC_PORT u1.State
    USHORT KtReadOperationCount;         // dt nt!_KTHREAD ReadOperationCount
    USHORT KtWriteOperationCount;        // dt nt!_KTHREAD WriteOperationCount
    USHORT KtOtherOperationCount;        // dt nt!_KTHREAD OtherOperationCount
    USHORT KtReadTransferCount;          // dt nt!_KTHREAD ReadTransferCount
    USHORT KtWriteTransferCount;         // dt nt!_KTHREAD WriteTransferCount
    USHORT KtOtherTransferCount;         // dt nt!_KTHREAD OtherTransferCount
    USHORT LxVersion;                    // lxcore.sys exports version
    USHORT LxPicoProc;                   // uf lxcore!LxpSyscall_GETPID
    USHORT LxPicoProcInfo;               // uf lxcore!LxpSyscall_GETPID
    USHORT LxPicoProcInfoPID;            // uf lxcore!LxpSyscall_GETPID
    USHORT LxPicoThrdInfo;               // uf lxcore!LxpSyscall_GETTID
    USHORT LxPicoThrdInfoTID;            // uf lxcore!LxpSyscall_GETTID
    USHORT MmSectionControlArea;         // dt nt!_SECTION u1.ControlArea
    USHORT MmControlAreaListHead;        // dt nt!_CONTROL_AREA ListHead
    USHORT MmControlAreaLock;            // dt nt!_CONTROL_AREA ControlAreaLock

}} KPH_DYN_CONFIGURATION, *PKPH_DYN_CONFIGURATION;

typedef struct _KPH_DYNDATA
{{
    ULONG Version;
    ULONG Count;
    KPH_DYN_CONFIGURATION Configs[ANYSIZE_ARRAY];

}} KPH_DYNDATA, *PKPH_DYNDATA;

#include <poppack.h>";

        [StructLayout(LayoutKind.Sequential, Pack = 1)]
        public struct DynConfig
        {
            public USHORT MajorVersion;
            public USHORT MinorVersion;
            public USHORT BuildNumberMin;
            public USHORT RevisionMin;
            public USHORT BuildNumberMax;
            public USHORT RevisionMax;

            public USHORT EgeGuid;
            public USHORT EpObjectTable;
            public USHORT EreGuidEntry;
            public USHORT HtHandleContentionEvent;
            public USHORT OtName;
            public USHORT OtIndex;
            public USHORT ObDecodeShift;
            public USHORT ObAttributesShift;
            public USHORT CiVersion;
            public USHORT AlpcCommunicationInfo;
            public USHORT AlpcOwnerProcess;
            public USHORT AlpcConnectionPort;
            public USHORT AlpcServerCommunicationPort;
            public USHORT AlpcClientCommunicationPort;
            public USHORT AlpcHandleTable;
            public USHORT AlpcHandleTableLock;
            public USHORT AlpcAttributes;
            public USHORT AlpcAttributesFlags;
            public USHORT AlpcPortContext;
            public USHORT AlpcPortObjectLock;
            public USHORT AlpcSequenceNo;
            public USHORT AlpcState;
            public USHORT KtReadOperationCount;
            public USHORT KtWriteOperationCount;
            public USHORT KtOtherOperationCount;
            public USHORT KtReadTransferCount;
            public USHORT KtWriteTransferCount;
            public USHORT KtOtherTransferCount;
            public USHORT LxVersion;
            public USHORT LxPicoProc;
            public USHORT LxPicoProcInfo;
            public USHORT LxPicoProcInfoPID;
            public USHORT LxPicoThrdInfo;
            public USHORT LxPicoThrdInfoTID;
            public USHORT MmSectionControlArea;
            public USHORT MmControlAreaListHead;
            public USHORT MmControlAreaLock;

            public DynConfig()
            {
                MajorVersion = ushort.MaxValue;
                MinorVersion = ushort.MaxValue;
                BuildNumberMin = ushort.MaxValue;
                BuildNumberMax = ushort.MaxValue;
                RevisionMin = ushort.MaxValue;
                RevisionMax = ushort.MaxValue;

                EgeGuid = ushort.MaxValue;
                EpObjectTable = ushort.MaxValue;
                EreGuidEntry = ushort.MaxValue;
                HtHandleContentionEvent = ushort.MaxValue;
                OtName = ushort.MaxValue;
                OtIndex = ushort.MaxValue;
                ObDecodeShift = ushort.MaxValue;
                ObAttributesShift = ushort.MaxValue;
                CiVersion = ushort.MaxValue;
                AlpcCommunicationInfo = ushort.MaxValue;
                AlpcOwnerProcess = ushort.MaxValue;
                AlpcConnectionPort = ushort.MaxValue;
                AlpcServerCommunicationPort = ushort.MaxValue;
                AlpcClientCommunicationPort = ushort.MaxValue;
                AlpcHandleTable = ushort.MaxValue;
                AlpcHandleTableLock = ushort.MaxValue;
                AlpcAttributes = ushort.MaxValue;
                AlpcAttributesFlags = ushort.MaxValue;
                AlpcPortContext = ushort.MaxValue;
                AlpcPortObjectLock = ushort.MaxValue;
                AlpcSequenceNo = ushort.MaxValue;
                AlpcState = ushort.MaxValue;
                KtReadOperationCount = ushort.MaxValue;
                KtWriteOperationCount = ushort.MaxValue;
                KtOtherOperationCount = ushort.MaxValue;
                KtReadTransferCount = ushort.MaxValue;
                KtWriteTransferCount = ushort.MaxValue;
                KtOtherTransferCount = ushort.MaxValue;
                LxVersion = ushort.MaxValue;
                LxPicoProc = ushort.MaxValue;
                LxPicoProcInfo = ushort.MaxValue;
                LxPicoProcInfoPID = ushort.MaxValue;
                LxPicoThrdInfo = ushort.MaxValue;
                LxPicoThrdInfoTID = ushort.MaxValue;
                MmSectionControlArea = ushort.MaxValue;
                MmControlAreaListHead = ushort.MaxValue;
                MmControlAreaLock = ushort.MaxValue;
            }
        }

        public static bool Execute()
        {
            const string manifestFile = "kphlib\\kphdyn.xml";
            const string headerFile = "kphlib\\include\\kphdyn.h";
            const string sourceFile = "kphlib\\kphdyn.c";

            if (!CreateHeader(headerFile))
                return false;
            if (!CreateSource(manifestFile, sourceFile))
                return false;

            return true;
        }

        private static bool CreateHeader(string FileName)
        {
            FileStreamOptions options = new FileStreamOptions
            {
                Mode = FileMode.Create,
                Access = FileAccess.Write,
                Share = FileShare.None,
                PreallocationSize = 0x2000, // 8KB
                //Options = FileOptions.SequentialScan
            };

            using (StreamWriter sw = new StreamWriter(FileName, Utils.UTF8NoBOM, options))
            {
                sw.WriteLine(FileHeader);
                sw.WriteLine();
                sw.WriteLine("#pragma once");
                sw.WriteLine();
                sw.WriteLine(Includes);
                sw.WriteLine();
                sw.WriteLine(DynConfigC);
                sw.WriteLine();
                sw.WriteLine("#ifdef _WIN64");
                sw.WriteLine("extern CONST BYTE KphDynData[];");
                sw.WriteLine("extern CONST ULONG KphDynDataLength;");
                sw.WriteLine("extern CONST BYTE KphDynDataSig[];");
                sw.WriteLine("extern CONST ULONG KphDynDataSigLength;");
                sw.WriteLine("#endif");
            }
#if DEBUG
            var filesize = Win32.GetFileSize(FileName);
            var filesizeondisk = 0x1000 * ((filesize + 0x1000 - 1) / 0x1000); // Assume 4k sector size (dmex)
            Debug.Assert(filesizeondisk == options.PreallocationSize, "Update PreallocationSize");
#endif
            return true;
        }

        private static bool CreateSource(string ManifestFile, string FileName)
        {
            FileStreamOptions options = new FileStreamOptions
            {
                Mode = FileMode.Create,
                Access = FileAccess.Write,
                Share = FileShare.None,
                PreallocationSize = 0x3000, // 12KB
                //Options = FileOptions.SequentialScan
            };

            if (!LoadConfig(ManifestFile, out string Config, out string Sig))
                return false;

            using (StreamWriter sw = new StreamWriter(FileName, Utils.UTF8NoBOM, options))
            {
                sw.WriteLine(FileHeader);
                sw.WriteLine();
                sw.WriteLine(Includes);
                sw.WriteLine();
                sw.WriteLine("#ifdef _WIN64");
                sw.WriteLine("CONST BYTE KphDynData[] =");
                sw.WriteLine("{");
                sw.Write(Config);
                sw.WriteLine("};");
                sw.WriteLine();
                sw.WriteLine("CONST ULONG KphDynDataLength = ARRAYSIZE(KphDynData);");
                sw.WriteLine();
                sw.WriteLine("CONST BYTE KphDynDataSig[] =");
                sw.WriteLine("{");
                sw.Write(Sig);
                sw.WriteLine("};");
                sw.WriteLine();
                sw.WriteLine("CONST ULONG KphDynDataSigLength = ARRAYSIZE(KphDynDataSig);");
                sw.WriteLine("#endif");
            }
#if DEBUG
            var filesize = Win32.GetFileSize(FileName);
            var filesizeondisk = 0x1000 * ((filesize + 0x1000 - 1) / 0x1000); // Assume 4k sector size (dmex)
            Debug.Assert(filesizeondisk == options.PreallocationSize, "Update PreallocationSize");
#endif
            return true;
        }

        /// <summary>
        /// This function generates a config structure for the current platform from XML
        /// </summary>
        /// <param name="ManifestFile">The configuration file.</param>
        /// <param name="ConfigData">The configuration file.</param>
        /// <param name="SigData"></param>
        /// <returns></returns>
        private static bool LoadConfig(
            string ManifestFile,
            out string ConfigData,
            out string SigData
            )
        {
            List<DynConfig> configList = new List<DynConfig>(10);
            List<string> configNames = new List<string>(10);
            byte[] configbuffer = null;
            byte[] signedbuffer = null;

            var xml = new XmlDocument();
            xml.Load(ManifestFile);

            var dyn = xml.SelectSingleNode("/dyn");
            var nodes = dyn?.SelectNodes("data");

            if (nodes == null)
            {
                Program.PrintColorMessage("Invalid config.", ConsoleColor.Red);
                ConfigData = null;
                SigData = null;
                return false;
            }

            foreach (XmlNode data in nodes)
            {
                var config = new DynConfig();
                var configName = data.Attributes?.GetNamedItem("name")?.Value;
                var fields = data.SelectNodes("field");

                if (fields == null)
                {
                    Program.PrintColorMessage("Invalid config.", ConsoleColor.Red);
                    ConfigData = null;
                    SigData = null;
                    return false;
                }

                Program.PrintColorMessage(configName, ConsoleColor.Cyan);

                foreach (XmlNode field in fields)
                {
                    string name = field.Attributes?.GetNamedItem("name")?.Value;
                    string value = field.Attributes?.GetNamedItem("value")?.Value;

                    if (string.IsNullOrEmpty(name))
                        continue;
                    if (string.IsNullOrEmpty(value))
                        continue;

                    FieldInfo member = typeof(DynConfig).GetField(name);

                    if (member == null)
                    {
                        Program.PrintColorMessage("Invalid config.", ConsoleColor.Red);
                        ConfigData = null;
                        SigData = null;
                        return false;
                    }

                    if (value.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
                    {
                        value = Convert.ToUInt64(value, 16).ToString();
                    }
                    else if (value.Equals("-1", StringComparison.OrdinalIgnoreCase) && member.FieldType == typeof(ushort))
                    {
                        value = ushort.MaxValue.ToString();
                    }

                    member.SetValueDirect(__makeref(config), Convert.ChangeType(value, member.FieldType));
                }

                configList.Add(config);
                configNames.Add(configName);
            }

            if (!Validate(configList, configNames))
            {
                Program.PrintColorMessage("Invalid config.", ConsoleColor.Red);
                ConfigData = null;
                SigData = null;
                return false;
            }

            using (MemoryStream stream = new MemoryStream())
            using (BinaryWriter writer = new BinaryWriter(stream))
            {
                //
                // Write the version and count first, then the blocks.
                // This conforms with KPH_DYNDATA defined above.
                //
                writer.Write(Version);
                writer.Write((uint)configList.Count);
                writer.Write(MemoryMarshal.AsBytes(CollectionsMarshal.AsSpan(configList)));

                configbuffer = stream.GetBuffer();
            }

            signedbuffer = Verify.SignData(VerifyCache.KMODE_CI, configbuffer);

            ConfigData = BufferToString(configbuffer);
            SigData = BufferToString(signedbuffer);
            return true;
        }

        private static bool Validate(IReadOnlyList<DynConfig> Configs, IReadOnlyList<string> ConfigNames)
        {
            bool valid = true;

            for (int i = 0; i < Configs.Count; i++)
            {
                var config = Configs[i];
                var configName = ConfigNames[i];

                if (config.MajorVersion == ushort.MaxValue)
                {
                    Program.PrintColorMessage($"{configName} - MajorVersion required", ConsoleColor.Red);
                    valid = false;
                }

                if (config.MinorVersion == ushort.MaxValue)
                {
                    Program.PrintColorMessage($"{configName} - MinorVersion required", ConsoleColor.Red);
                    valid = false;
                }

                if (config.BuildNumberMax < config.BuildNumberMin)
                {
                    Program.PrintColorMessage($"{configName} - BuildNumber range is invalid", ConsoleColor.Red);
                    valid = false;
                }

                if (config.BuildNumberMax == config.BuildNumberMin &&
                    config.RevisionMax < config.RevisionMin)
                {
                    Program.PrintColorMessage($"{configName} - Revision range is invalid", ConsoleColor.Red);
                    valid = false;
                }
            }

            return valid;
        }

        private static unsafe string BufferToString(byte[] Buffer)
        {
            using (MemoryStream stream = new MemoryStream(Buffer, false))
            {
                StringBuilder hex = new StringBuilder(64);
                StringBuilder sb = new StringBuilder(8192);
                Span<byte> bytes = stackalloc byte[8];

                while (true)
                {
                    int length = stream.Read(bytes);

                    if (length == 0)
                        break;

                    for (int i = 0; i < length; i++)
                    {
                        hex.Append($"0x{bytes[i]:x2}, ");
                    }
                    hex.Remove(hex.Length - 1, 1);

                    sb.Append("    ");
                    sb.AppendLine(hex.ToString());
                    hex.Clear();

                    if (length < bytes.Length)
                        break;
                }

                return sb.ToString();
            }
        }
    }
}
